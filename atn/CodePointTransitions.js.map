{"version":3,"file":"CodePointTransitions.js","sourceRoot":"","sources":["../../../src/atn/CodePointTransitions.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,SAAS,MAAM,sBAAsB,CAAA;AAEjD,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AACpD,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAA;AACpD,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;AACtD,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAGlD;;;;;;;;;GASG;AAEH;;;GAGG;AACH,MAAM,UAAU,mBAAmB,CAAC,MAAgB,EAAE,SAAiB;IACtE,IAAI,SAAS,CAAC,wBAAwB,CAAC,SAAS,CAAC,EAAE;QAClD,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,WAAW,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;KAC5D;SACI;QACJ,OAAO,IAAI,cAAc,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;KAC7C;AACF,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CAAC,MAAgB,EAAE,aAAqB,EAAE,WAAmB;IACpG,IAAI,SAAS,CAAC,wBAAwB,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,wBAAwB,CAAC,WAAW,CAAC,EAAE;QACzG,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,WAAW,CAAC,EAAE,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC,CAAC;KAC7E;SACI;QACJ,OAAO,IAAI,eAAe,CAAC,MAAM,EAAE,aAAa,EAAE,WAAW,CAAC,CAAC;KAC/D;AACF,CAAC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport * as Character from \"../misc/Character.js\"\nimport { ATNState } from \"./ATNState.js\"\nimport { AtomTransition } from \"./AtomTransition.js\"\nimport { IntervalSet } from \"../misc/IntervalSet.js\"\nimport { RangeTransition } from \"./RangeTransition.js\"\nimport { SetTransition } from \"./SetTransition.js\"\nimport { Transition } from \"./Transition.js\"\n\n/**\n * Utility functions to create {@link AtomTransition}, {@link RangeTransition},\n * and {@link SetTransition} appropriately based on the range of the input.\n *\n * To keep the serialized ATN size small, we only inline atom and\n * range transitions for Unicode code points <= U+FFFF.\n *\n * Whenever we encounter a Unicode code point > U+FFFF, we represent that\n * as a set transition (even if it is logically an atom or a range).\n */\n\n/**\n * If {@code codePoint} is <= U+FFFF, returns a new {@link AtomTransition}.\n * Otherwise, returns a new {@link SetTransition}.\n */\nexport function createWithCodePoint(target: ATNState, codePoint: number): Transition {\n\tif (Character.isSupplementaryCodePoint(codePoint)) {\n\t\treturn new SetTransition(target, IntervalSet.of(codePoint));\n\t}\n\telse {\n\t\treturn new AtomTransition(target, codePoint);\n\t}\n}\n\n/**\n * If {@code codePointFrom} and {@code codePointTo} are both\n * <= U+FFFF, returns a new {@link RangeTransition}.\n * Otherwise, returns a new {@link SetTransition}.\n */\nexport function createWithCodePointRange(target: ATNState, codePointFrom: number, codePointTo: number): Transition {\n\tif (Character.isSupplementaryCodePoint(codePointFrom) || Character.isSupplementaryCodePoint(codePointTo)) {\n\t\treturn new SetTransition(target, IntervalSet.of(codePointFrom, codePointTo));\n\t}\n\telse {\n\t\treturn new RangeTransition(target, codePointFrom, codePointTo);\n\t}\n}\n"]}