{"version":3,"file":"PredicateTransition.js","sourceRoot":"","sources":["../../../src/atn/PredicateTransition.ts"],"names":[],"mappings":"AAAA;;;GAGG;;;;;;;;;;AAEH,wDAAwD;AAExD,OAAO,EAAE,2BAA2B,EAAE,MAAM,kCAAkC,CAAA;AAE9E,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAA;AACpD,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;AAGtD;;;;;GAKG;AACI,IAAM,mBAAmB,GAAzB,MAAM,mBAAoB,SAAQ,2BAA2B;IAC5D,SAAS,CAAS;IAClB,SAAS,CAAS;IAClB,cAAc,CAAU,CAAG,uBAAuB;IAEzD,YAAqB,MAAgB,EAAE,SAAiB,EAAE,SAAiB,EAAE,cAAuB;QACnG,KAAK,CAAC,MAAM,CAAC,CAAC;QACd,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACtC,CAAC;IAGD,IAAI,iBAAiB;QACpB,wCAAgC;IACjC,CAAC;IAGD,IAAI,SAAS,KAAc,OAAO,IAAI,CAAC,CAAC,CAAC;IAGlC,OAAO,CAAC,MAAc,EAAE,cAAsB,EAAE,cAAsB;QAC5E,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,SAAS;QACZ,OAAO,IAAI,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;IAC3F,CAAC;IAIM,QAAQ;QACd,OAAO,OAAO,GAAG,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC;IACxD,CAAC;CACD,CAAA;AArBA;IADC,QAAQ;4DAGR;AAGD;IADC,QAAQ;oDACgC;AAGzC;IADC,QAAQ;kDAGR;AAQD;IAFC,QAAQ;IACR,OAAO;mDAGP;AAjCW,mBAAmB;IAKlB,WAAA,OAAO,CAAA;GALR,mBAAmB,CAkC/B;SAlCY,mBAAmB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:35.2826960-07:00\n\nimport { AbstractPredicateTransition } from \"./AbstractPredicateTransition.js\"\nimport { ATNState } from \"./ATNState.js\"\nimport { NotNull, Override } from \"../Decorators.js\"\nimport { SemanticContext } from \"./SemanticContext.js\"\nimport { TransitionType } from \"./TransitionType.js\"\n\n/** TODO: this is old comment:\n *  A tree of semantic predicates from the grammar AST if label==SEMPRED.\n *  In the ATN, labels will always be exactly one predicate, but the DFA\n *  may have to combine a bunch of them as it collects predicates from\n *  multiple ATN configurations into a single DFA state.\n */\nexport class PredicateTransition extends AbstractPredicateTransition {\n\tpublic ruleIndex: number;\n\tpublic predIndex: number;\n\tpublic isCtxDependent: boolean;   // e.g., $i ref in pred\n\n\tconstructor(@NotNull target: ATNState, ruleIndex: number, predIndex: number, isCtxDependent: boolean) {\n\t\tsuper(target);\n\t\tthis.ruleIndex = ruleIndex;\n\t\tthis.predIndex = predIndex;\n\t\tthis.isCtxDependent = isCtxDependent;\n\t}\n\n\t@Override\n\tget serializationType(): TransitionType {\n\t\treturn TransitionType.PREDICATE;\n\t}\n\n\t@Override\n\tget isEpsilon(): boolean { return true; }\n\n\t@Override\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\n\t\treturn false;\n\t}\n\n\tget predicate(): SemanticContext.Predicate {\n\t\treturn new SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n\t}\n\n\t@Override\n\t@NotNull\n\tpublic toString(): string {\n\t\treturn \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n\t}\n}\n"]}