{"version":3,"file":"DecisionInfo.js","sourceRoot":"","sources":["../../../src/atn/DecisionInfo.ts"],"names":[],"mappings":"AAAA;;;GAGG;;;;;;;AAQH,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAA;AAG3C;;;;;;;;;;;GAWG;AACH,MAAM,OAAO,YAAY;IACxB;;OAEG;IACI,QAAQ,CAAS;IAExB;;;OAGG;IACI,WAAW,GAAW,CAAC,CAAC;IAE/B;;;;;;;;;;;;OAYG;IACI,gBAAgB,GAAW,CAAC,CAAC;IAEpC;;;;;OAKG;IACI,aAAa,GAAW,CAAC,CAAC;IAEjC;;;;OAIG;IACI,WAAW,GAAW,CAAC,CAAC;IAE/B;;;;OAIG;IACI,WAAW,GAAW,CAAC,CAAC;IAE/B;;;OAGG;IACI,gBAAgB,CAAsB;IAE7C;;;;OAIG;IACI,YAAY,GAAW,CAAC,CAAC;IAEhC;;;;;;OAMG;IACI,UAAU,GAAW,CAAC,CAAC;IAE9B;;;;;;OAMG;IACI,UAAU,GAAW,CAAC,CAAC;IAE9B;;;OAGG;IACI,eAAe,CAAsB;IAE5C;;;;;OAKG;IACI,oBAAoB,GAA6B,EAAE,CAAC;IAE3D;;;;;;OAMG;IACI,MAAM,GAAgB,EAAE,CAAC;IAEhC;;;;;OAKG;IACI,WAAW,GAAoB,EAAE,CAAC;IAEzC;;;;;;OAMG;IACI,cAAc,GAAwB,EAAE,CAAC;IAEhD;;;;;;;;;;;;;;OAcG;IACI,kBAAkB,GAAW,CAAC,CAAC;IAEtC;;;;;;;;;OASG;IACI,kBAAkB,GAAW,CAAC,CAAC;IAEtC;;;;;;;;;;OAUG;IACI,WAAW,GAAW,CAAC,CAAC;IAE/B;;;;;;;;;;;;;;OAcG;IACI,iBAAiB,GAAW,CAAC,CAAC;IAErC;;;;;;;;;OASG;IACI,iBAAiB,GAAW,CAAC,CAAC;IAErC;;;;;OAKG;IACH,YAAY,QAAgB;QAC3B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC1B,CAAC;IAGM,QAAQ;QACd,OAAO,GAAG;YACT,WAAW,GAAG,IAAI,CAAC,QAAQ;YAC3B,yBAAyB,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM;YAC5D,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM;YAChC,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;YAC1C,kBAAkB,GAAG,IAAI,CAAC,aAAa;YACvC,uBAAuB,GAAG,IAAI,CAAC,kBAAkB;YACjD,uBAAuB,GAAG,IAAI,CAAC,kBAAkB;YACjD,gBAAgB,GAAG,IAAI,CAAC,WAAW;YACnC,iBAAiB,GAAG,IAAI,CAAC,YAAY;YACrC,sBAAsB,GAAG,IAAI,CAAC,iBAAiB;YAC/C,GAAG,CAAC;IACN,CAAC;CACD;AAdA;IADC,QAAQ;4CAcR","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:28.3330673-07:00\n\nimport { AmbiguityInfo } from \"./AmbiguityInfo.js\"\nimport { ContextSensitivityInfo } from \"./ContextSensitivityInfo.js\"\nimport { ErrorInfo } from \"./ErrorInfo.js\"\nimport { LookaheadEventInfo } from \"./LookaheadEventInfo.js\"\nimport { Override } from \"../Decorators.js\"\nimport { PredicateEvalInfo } from \"./PredicateEvalInfo.js\"\n\n/**\n * This class contains profiling gathered for a particular decision.\n *\n * Parsing performance in ANTLR 4 is heavily influenced by both static factors\n * (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the\n * choice of input and the state of the DFA cache at the time profiling\n * operations are started). For best results, gather and use aggregate\n * statistics from a large sample of inputs representing the inputs expected in\n * production before using the results to make changes in the grammar.\n *\n * @since 4.3\n */\nexport class DecisionInfo {\n\t/**\n\t * The decision number, which is an index into {@link ATN#decisionToState}.\n\t */\n\tpublic decision: number;\n\n\t/**\n\t * The total number of times {@link ParserATNSimulator#adaptivePredict} was\n\t * invoked for this decision.\n\t */\n\tpublic invocations: number = 0;\n\n\t/**\n\t * The total time spent in {@link ParserATNSimulator#adaptivePredict} for\n\t * this decision, in nanoseconds.\n\t *\n\t * The value of this field contains the sum of differential results obtained\n\t * by {@link System#nanoTime()}, and is not adjusted to compensate for JIT\n\t * and/or garbage collection overhead. For best accuracy, use a modern JVM\n\t * implementation that provides precise results from\n\t * {@link System#nanoTime()}, and perform profiling in a separate process\n\t * which is warmed up by parsing the input prior to profiling. If desired,\n\t * call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial\n\t * state before starting the profiling measurement pass.\n\t */\n\tpublic timeInPrediction: number = 0;\n\n\t/**\n\t * The sum of the lookahead required for SLL prediction for this decision.\n\t * Note that SLL prediction is used before LL prediction for performance\n\t * reasons even when {@link PredictionMode#LL} or\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\n\t */\n\tpublic SLL_TotalLook: number = 0;\n\n\t/**\n\t * Gets the minimum lookahead required for any single SLL prediction to\n\t * complete for this decision, by reaching a unique prediction, reaching an\n\t * SLL conflict state, or encountering a syntax error.\n\t */\n\tpublic SLL_MinLook: number = 0;\n\n\t/**\n\t * Gets the maximum lookahead required for any single SLL prediction to\n\t * complete for this decision, by reaching a unique prediction, reaching an\n\t * SLL conflict state, or encountering a syntax error.\n\t */\n\tpublic SLL_MaxLook: number = 0;\n\n\t/**\n\t * Gets the {@link LookaheadEventInfo} associated with the event where the\n\t * {@link #SLL_MaxLook} value was set.\n\t */\n\tpublic SLL_MaxLookEvent?: LookaheadEventInfo;\n\n\t/**\n\t * The sum of the lookahead required for LL prediction for this decision.\n\t * Note that LL prediction is only used when SLL prediction reaches a\n\t * conflict state.\n\t */\n\tpublic LL_TotalLook: number = 0;\n\n\t/**\n\t * Gets the minimum lookahead required for any single LL prediction to\n\t * complete for this decision. An LL prediction completes when the algorithm\n\t * reaches a unique prediction, a conflict state (for\n\t * {@link PredictionMode#LL}, an ambiguity state (for\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n\t */\n\tpublic LL_MinLook: number = 0;\n\n\t/**\n\t * Gets the maximum lookahead required for any single LL prediction to\n\t * complete for this decision. An LL prediction completes when the algorithm\n\t * reaches a unique prediction, a conflict state (for\n\t * {@link PredictionMode#LL}, an ambiguity state (for\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n\t */\n\tpublic LL_MaxLook: number = 0;\n\n\t/**\n\t * Gets the {@link LookaheadEventInfo} associated with the event where the\n\t * {@link #LL_MaxLook} value was set.\n\t */\n\tpublic LL_MaxLookEvent?: LookaheadEventInfo;\n\n\t/**\n\t * A collection of {@link ContextSensitivityInfo} instances describing the\n\t * context sensitivities encountered during LL prediction for this decision.\n\t *\n\t * @see ContextSensitivityInfo\n\t */\n\tpublic contextSensitivities: ContextSensitivityInfo[] = [];\n\n\t/**\n\t * A collection of {@link ErrorInfo} instances describing the parse errors\n\t * identified during calls to {@link ParserATNSimulator#adaptivePredict} for\n\t * this decision.\n\t *\n\t * @see ErrorInfo\n\t */\n\tpublic errors: ErrorInfo[] = [];\n\n\t/**\n\t * A collection of {@link AmbiguityInfo} instances describing the\n\t * ambiguities encountered during LL prediction for this decision.\n\t *\n\t * @see AmbiguityInfo\n\t */\n\tpublic ambiguities: AmbiguityInfo[] = [];\n\n\t/**\n\t * A collection of {@link PredicateEvalInfo} instances describing the\n\t * results of evaluating individual predicates during prediction for this\n\t * decision.\n\t *\n\t * @see PredicateEvalInfo\n\t */\n\tpublic predicateEvals: PredicateEvalInfo[] = [];\n\n\t/**\n\t * The total number of ATN transitions required during SLL prediction for\n\t * this decision. An ATN transition is determined by the number of times the\n\t * DFA does not contain an edge that is required for prediction, resulting\n\t * in on-the-fly computation of that edge.\n\t *\n\t * If DFA caching of SLL transitions is employed by the implementation, ATN\n\t * computation may cache the computed edge for efficient lookup during\n\t * future parsing of this decision. Otherwise, the SLL parsing algorithm\n\t * will use ATN transitions exclusively.\n\t *\n\t * @see #SLL_ATNTransitions\n\t * @see ParserATNSimulator#computeTargetState\n\t * @see LexerATNSimulator#computeTargetState\n\t */\n\tpublic SLL_ATNTransitions: number = 0;\n\n\t/**\n\t * The total number of DFA transitions required during SLL prediction for\n\t * this decision.\n\t *\n\t * If the ATN simulator implementation does not use DFA caching for SLL\n\t * transitions, this value will be 0.\n\t *\n\t * @see ParserATNSimulator#getExistingTargetState\n\t * @see LexerATNSimulator#getExistingTargetState\n\t */\n\tpublic SLL_DFATransitions: number = 0;\n\n\t/**\n\t * Gets the total number of times SLL prediction completed in a conflict\n\t * state, resulting in fallback to LL prediction.\n\t *\n\t * Note that this value is not related to whether or not\n\t * {@link PredictionMode#SLL} may be used successfully with a particular\n\t * grammar. If the ambiguity resolution algorithm applied to the SLL\n\t * conflicts for this decision produce the same result as LL prediction for\n\t * this decision, {@link PredictionMode#SLL} would produce the same overall\n\t * parsing result as {@link PredictionMode#LL}.\n\t */\n\tpublic LL_Fallback: number = 0;\n\n\t/**\n\t * The total number of ATN transitions required during LL prediction for\n\t * this decision. An ATN transition is determined by the number of times the\n\t * DFA does not contain an edge that is required for prediction, resulting\n\t * in on-the-fly computation of that edge.\n\t *\n\t * If DFA caching of LL transitions is employed by the implementation, ATN\n\t * computation may cache the computed edge for efficient lookup during\n\t * future parsing of this decision. Otherwise, the LL parsing algorithm will\n\t * use ATN transitions exclusively.\n\t *\n\t * @see #LL_DFATransitions\n\t * @see ParserATNSimulator#computeTargetState\n\t * @see LexerATNSimulator#computeTargetState\n\t */\n\tpublic LL_ATNTransitions: number = 0;\n\n\t/**\n\t * The total number of DFA transitions required during LL prediction for\n\t * this decision.\n\t *\n\t * If the ATN simulator implementation does not use DFA caching for LL\n\t * transitions, this value will be 0.\n\t *\n\t * @see ParserATNSimulator#getExistingTargetState\n\t * @see LexerATNSimulator#getExistingTargetState\n\t */\n\tpublic LL_DFATransitions: number = 0;\n\n\t/**\n\t * Constructs a new instance of the {@link DecisionInfo} class to contain\n\t * statistics for a particular decision.\n\t *\n\t * @param decision The decision number\n\t */\n\tconstructor(decision: number) {\n\t\tthis.decision = decision;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\treturn \"{\" +\n\t\t\t\"decision=\" + this.decision +\n\t\t\t\", contextSensitivities=\" + this.contextSensitivities.length +\n\t\t\t\", errors=\" + this.errors.length +\n\t\t\t\", ambiguities=\" + this.ambiguities.length +\n\t\t\t\", SLL_lookahead=\" + this.SLL_TotalLook +\n\t\t\t\", SLL_ATNTransitions=\" + this.SLL_ATNTransitions +\n\t\t\t\", SLL_DFATransitions=\" + this.SLL_DFATransitions +\n\t\t\t\", LL_Fallback=\" + this.LL_Fallback +\n\t\t\t\", LL_lookahead=\" + this.LL_TotalLook +\n\t\t\t\", LL_ATNTransitions=\" + this.LL_ATNTransitions +\n\t\t\t\"}\";\n\t}\n}\n"]}