{"version":3,"file":"ParseTreePattern.js","sourceRoot":"","sources":["../../../../src/tree/pattern/ParseTreePattern.ts"],"names":[],"mappings":"AAAA;;;GAGG;;;;;;;;;;AAEH,+CAA+C;AAC/C,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAA;AAI7C,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAA;AAEzC;;;GAGG;AACI,IAAM,gBAAgB,GAAtB,MAAM,gBAAgB;IAC5B;;OAEG;IACK,iBAAiB,CAAS;IAElC;;OAEG;IAEK,QAAQ,CAAS;IAEzB;;OAEG;IAEK,YAAY,CAAY;IAEhC;;OAEG;IAEK,QAAQ,CAA0B;IAE1C;;;;;;;;;OASG;IACH,YACU,OAAgC,EAChC,OAAe,EACxB,gBAAwB,EACf,WAAsB;QAC/B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;QAC1C,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;IACjC,CAAC;IAED;;;;;;;OAOG;IAEI,KAAK,CAAU,IAAe;QACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACxC,CAAC;IAED;;;;;;OAMG;IACI,OAAO,CAAU,IAAe;QACtC,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,SAAS,CAAC;IAClD,CAAC;IAED;;;;;;;;;;OAUG;IAEI,OAAO,CAAU,IAAe,EAAW,KAAa;QAC9D,IAAI,QAAQ,GAAmB,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAChF,IAAI,OAAO,GAAqB,EAAE,CAAC;QACnC,KAAK,IAAI,CAAC,IAAI,QAAQ,EAAE;YACvB,IAAI,KAAK,GAAmB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI,KAAK,CAAC,SAAS,EAAE;gBACpB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACpB;SACD;QACD,OAAO,OAAO,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IAEH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED;;;;OAIG;IAEH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACH,IAAI,gBAAgB;QACnB,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IAEH,IAAI,WAAW;QACd,OAAO,IAAI,CAAC,YAAY,CAAC;IAC1B,CAAC;CACD,CAAA;AA9HA;IADC,OAAO;kDACiB;AAMzB;IADC,OAAO;sDACwB;AAMhC;IADC,OAAO;kDACkC;AA+B1C;IAAC,OAAO;IACM,WAAA,OAAO,CAAA;6CAEpB;AASD;IAAgB,WAAA,OAAO,CAAA;+CAEtB;AAaD;IAAC,OAAO;IACQ,WAAA,OAAO,CAAA;IAAmB,WAAA,OAAO,CAAA;+CAUhD;AASD;IADC,OAAO;+CAGP;AAQD;IADC,OAAO;+CAGP;AAqBD;IADC,OAAO;mDAGP;AAvIW,gBAAgB;IAmC1B,WAAA,OAAO,CAAA;IACP,WAAA,OAAO,CAAA;IAEP,WAAA,OAAO,CAAA;GAtCG,gBAAgB,CAwI5B;SAxIY,gBAAgB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// CONVERSTION complete, Burt Harris 10/14/2016\nimport { NotNull } from \"../../Decorators.js\"\nimport { ParseTree } from \"../ParseTree.js\"\nimport { ParseTreeMatch } from \"./ParseTreeMatch.js\"\nimport { ParseTreePatternMatcher } from \"./ParseTreePatternMatcher.js\"\nimport { XPath } from \"../xpath/XPath.js\"\n\n/**\n * A pattern like `<ID> = <expr>;` converted to a {@link ParseTree} by\n * {@link ParseTreePatternMatcher#compile(String, int)}.\n */\nexport class ParseTreePattern {\n\t/**\n\t * This is the backing field for `patternRuleIndex`.\n\t */\n\tprivate _patternRuleIndex: number;\n\n\t/**\n\t * This is the backing field for `pattern`.\n\t */\n\t@NotNull\n\tprivate _pattern: string;\n\n\t/**\n\t * This is the backing field for `patternTree`.\n\t */\n\t@NotNull\n\tprivate _patternTree: ParseTree;\n\n\t/**\n\t * This is the backing field for `matcher`.\n\t */\n\t@NotNull\n\tprivate _matcher: ParseTreePatternMatcher;\n\n\t/**\n\t * Construct a new instance of the {@link ParseTreePattern} class.\n\t *\n\t * @param matcher The {@link ParseTreePatternMatcher} which created this\n\t * tree pattern.\n\t * @param pattern The tree pattern in concrete syntax form.\n\t * @param patternRuleIndex The parser rule which serves as the root of the\n\t * tree pattern.\n\t * @param patternTree The tree pattern in {@link ParseTree} form.\n\t */\n\tconstructor(\n\t\t@NotNull matcher: ParseTreePatternMatcher,\n\t\t@NotNull pattern: string,\n\t\tpatternRuleIndex: number,\n\t\t@NotNull patternTree: ParseTree) {\n\t\tthis._matcher = matcher;\n\t\tthis._patternRuleIndex = patternRuleIndex;\n\t\tthis._pattern = pattern;\n\t\tthis._patternTree = patternTree;\n\t}\n\n\t/**\n\t * Match a specific parse tree against this tree pattern.\n\t *\n\t * @param tree The parse tree to match against this tree pattern.\n\t * @returns A {@link ParseTreeMatch} object describing the result of the\n\t * match operation. The `ParseTreeMatch.succeeded` method can be\n\t * used to determine whether or not the match was successful.\n\t */\n\t@NotNull\n\tpublic match(@NotNull tree: ParseTree): ParseTreeMatch {\n\t\treturn this._matcher.match(tree, this);\n\t}\n\n\t/**\n\t * Determine whether or not a parse tree matches this tree pattern.\n\t *\n\t * @param tree The parse tree to match against this tree pattern.\n\t * @returns `true` if `tree` is a match for the current tree\n\t * pattern; otherwise, `false`.\n\t */\n\tpublic matches(@NotNull tree: ParseTree): boolean {\n\t\treturn this._matcher.match(tree, this).succeeded;\n\t}\n\n\t/**\n\t * Find all nodes using XPath and then try to match those subtrees against\n\t * this tree pattern.\n\t *\n\t * @param tree The {@link ParseTree} to match against this pattern.\n\t * @param xpath An expression matching the nodes\n\t *\n\t * @returns A collection of {@link ParseTreeMatch} objects describing the\n\t * successful matches. Unsuccessful matches are omitted from the result,\n\t * regardless of the reason for the failure.\n\t */\n\t@NotNull\n\tpublic findAll(@NotNull tree: ParseTree, @NotNull xpath: string): ParseTreeMatch[] {\n\t\tlet subtrees: Set<ParseTree> = XPath.findAll(tree, xpath, this._matcher.parser);\n\t\tlet matches: ParseTreeMatch[] = [];\n\t\tfor (let t of subtrees) {\n\t\t\tlet match: ParseTreeMatch = this.match(t);\n\t\t\tif (match.succeeded) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\t/**\n\t * Get the {@link ParseTreePatternMatcher} which created this tree pattern.\n\t *\n\t * @returns The {@link ParseTreePatternMatcher} which created this tree\n\t * pattern.\n\t */\n\t@NotNull\n\tget matcher(): ParseTreePatternMatcher {\n\t\treturn this._matcher;\n\t}\n\n\t/**\n\t * Get the tree pattern in concrete syntax form.\n\t *\n\t * @returns The tree pattern in concrete syntax form.\n\t */\n\t@NotNull\n\tget pattern(): string {\n\t\treturn this._pattern;\n\t}\n\n\t/**\n\t * Get the parser rule which serves as the outermost rule for the tree\n\t * pattern.\n\t *\n\t * @returns The parser rule which serves as the outermost rule for the tree\n\t * pattern.\n\t */\n\tget patternRuleIndex(): number {\n\t\treturn this._patternRuleIndex;\n\t}\n\n\t/**\n\t * Get the tree pattern as a {@link ParseTree}. The rule and token tags from\n\t * the pattern are present in the parse tree as terminal nodes with a symbol\n\t * of type {@link RuleTagToken} or {@link TokenTagToken}.\n\t *\n\t * @returns The tree pattern as a {@link ParseTree}.\n\t */\n\t@NotNull\n\tget patternTree(): ParseTree {\n\t\treturn this._patternTree;\n\t}\n}\n"]}